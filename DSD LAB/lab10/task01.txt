module Clock_Divider (
    input clock_in,
    output reg clock_out = 0
);
    reg [27:0] counter = 28'd0;
    parameter DIVISOR = 28'd100000000;

    always @(posedge clock_in) begin
        if (counter == DIVISOR - 1) begin
            counter <= 0;
            clock_out <= ~clock_out;
        end else begin
            counter <= counter + 1;
        end
    end
endmodule

module df1(output reg q, input d, input clk);
    always @(posedge clk) begin
            q <= d;
    end
endmodule

module synchronizer(
    input clk,
    input btn,
    output synch_btn
);
    wire q1;
    df1 d1(q1, btn, clk);
    df1 d2(synch_btn, q1, clk);
endmodule

module level_to_pulse(
    input clk,
    input synch_input,
    output pulse
);
    wire q;
    df1 d1(q, synch_input, clk);
    assign pulse = synch_input & ~q;
endmodule

module button(
    input clk,
    input btn_in,
    output btn_out
);
    wire sync;
    synchronizer s1(clk, btn_in, sync);
    level_to_pulse p1(clk, sync,btn_out);
endmodule

module lock(
    input clk, reset_in, b0_in, b1_in,
    output out,
    output [2:0] hex_display
);
    wire reset, b0, b1;

    button b_reset(clk,reset_in, reset);
    button b_0(clk, b0_in, b0);
    button b_1(clk,b1_in, b1);

    parameter S0=3'b000, S1=3'b001, S2=3'b010, S3=3'b011, S4=3'b100, S5=3'b101;
    reg [2:0] state = S0, next_state;

    always @(*) begin
        if (reset)
            next_state = S0;
        else
            case (state)
                S0: next_state = b0 ? S1 : b1 ?S0:state;
                S1: next_state = b0 ? S1 : b1 ?S2:state;
                S2: next_state = b0 ? S3 : b1 ?S0:state;
                S3: next_state = b0 ? S1 : b1 ?S4:state;
                S4: next_state = b0 ? S3 : b1 ?S5:state;
                S5: next_state = b0 ? S1 : b1 ?S0:state;
                default: next_state = S0;
            endcase
    end

    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end

    assign out = (state == S5);
    assign hex_display = state;
endmodule

module BCD_to_7seg(input [2:0] bcd, output reg [7:0] seg);
    always @(*) begin
        case(bcd)
            3'b000: seg = 8'b10000001; // 0
            3'b001: seg = 8'b11110011; // 1
            3'b010: seg = 8'b01001001; // 2
            3'b011: seg = 8'b01100001; // 3
            3'b100: seg = 8'b00110011; // 4
            3'b101: seg = 8'b00100101; // 5
            default: seg = 8'b11111111; // blank
        endcase
    end
endmodule

module Top(
    input clk,
    input rst,
    input btn0,
    input btn1,
    output out,
    output [7:0] seg
);
    wire slow_clock;
    wire [2:0] display;

    Clock_Divider d1(clk, slow_clock);
    lock L(slow_clock, rst, btn0, btn1, out, display);
    BCD_to_7seg b(display, seg);
endmodule
